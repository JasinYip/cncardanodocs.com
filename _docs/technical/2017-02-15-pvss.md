---
layout: default
title: 卡尔达诺结算层 PVSS
permalink: /technical/pvss/
group: technical
visible: true
---
<!-- Reviewed at 18852484704ff4a7ce3fcac2791499c340eb8e02 -->

# 卡尔达诺结算层中PVSS的实现 

卡尔达诺结算层使用公开验证密钥共享模式，它基于『SCRAPE：可扩展的随机性公共实体证明』这篇由 Ignacio Cascudo 和 Bernardo David 写的[论文](https://eprint.iacr.org/2017/216.pdf)。接下来我们将引用论文中的页，比如 `[6]` 表示第6页。

本指南介绍了[卡尔达诺结算层](https://github.com/input-output-hk/cardano-sl/blob/65e295599817ec1f52f225810264d856f882fbb7/core/Pos/Crypto/SecretSharing.hs#L1)中 `pvss-haskell` [库](https://github.com/input-output-hk/pvss-haskell)的实现细节。

## 什么是 PVSS

VSS 模式的核心思想是参与者验证自己的份额，成功构建密钥（之前由参与者中的经销商分发（TODO））的能力。而 PVSS 模式的核心思想是，参与者不仅可以验证其股权，而且任何人都可以验证参与者是否收到了正确的股权。因此（参考我们的重建协议），参与者不仅要发行他们的股权，还要为每个发行的股票提供一个正确地证明(`[9]`)。（TODO）

我们使用 `t-out-of-n` 重建方案(`[8]`)，其中 `n` 是参与者的数量，`t` 是一个阈值。所以任何 `t+1` 份额的子集可以用来成功恢复密钥。

所以，协议有四个基本阶段(`[8]`)组成：

1. 建立，
2. 分配，
3. 验证，
4. 重建。

## 建立

每个参与者 `Pi` 必须生成器私钥 `SKi` 并注册其公钥 `PKi`。

## 分配

首先，我们准备一个新的托管环境。要做到这一点，我们需要上面提到的[阈值](https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS.hs#L76)和参与者的[公钥清单](https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS.hs#L175)。该操作的结果是 [`Escrow`](https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS.hs#L120)，它包括：

1.  [额外的生成器](https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS.hs#L85)，
2.  [多项式](https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS/Polynomial.hs#L24)，
3.  [密钥](https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS.hs#L89)，
4.  [证明](https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS/DLEQ.hs#L39)。

额外的生成器基于一个[点](https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS/ECC.hs#L92)（[椭圆曲线点](http://hackage.haskell.org/package/cryptonite-openssl-0.6/docs/Crypto-OpenSSL-ECC.html#t:EcPoint)）。我们使用 `prime256v1` 椭圆曲线，参见 [RFC](https://www.ietf.org/rfc/rfc5480.txt)。

多项式是一组从 smallest degree 开始的一组系数（这些系统是[标](http://hackage.haskell.org/package/cryptonite-0.23/docs/Crypto-PubKey-ECC-P256.html#t:Scalar)值）。

密钥也基于一个[点](https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS/ECC.hs#L92)，实际上它是上面提到的多项式的第一个[元素](https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS.hs#L140)。

证明从[挑战](https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS.hs#L142)，[原始密钥](https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS.hs#L140)，[DEEQ-参数生成](https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS.hs#L143)[生成](https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS/DLEQ.hs#L62)

Proof is
[generated](https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS/DLEQ.hs#L62)
from a
[challenge](https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS.hs#L142),
[raw
secret](https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS.hs#L140)
and
[DLEQ-parameters](https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS.hs#L143).

Challenge is based on [cryptographic
hash](https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS/ECC.hs#L125).

After that we have to [finish escrow
creation](https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS.hs#L168).
List of participants' public keys is used to [create encrypted
shares](https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS.hs#L202)
and
[commitments](https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS.hs#L188).
Encrypted share inсludes:

1.  [Share ID](https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS.hs#L82),
2.  [Value](https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS.hs#L99)
    encrypted by participant's public key,
3.  [Proof](https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS.hs#L99)
    that this share is valid (`[8]`).

## Verification

Now commitments and encrypted shares can be published among participants. Due
the public nature of PVSS scheme anyone who knows public keys can [verify
decrypted
shares](https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS.hs#L249)
via hashes matching (`[8]`).

## Reconstruction

First of all, participant must [decrypt encrypted
share](https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS.hs#L230)
using [keys
pair](https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS/ECC.hs#L59)
with its
[private](https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS/ECC.hs#L80)
and
[public](https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS/ECC.hs#L84)
keys. To obtain DLEQ value, we use `prime256v1` [curve
generator](https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS/ECC.hs#L156).
As a result, we get
[`DecryptedShare`](https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS.hs#L109).
Its structure is the same as encrypted share.

Since decrypted share contains a proof, we can be sure that decrypted share is
the same as encrypted one, there's [verification
function](https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS.hs#L260)
for it. To [do
it](https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS/DLEQ.hs#L74)
we use DLEQ value and [proof from the decrypted
share](https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS.hs#L263).
Actual verifying is a
[comparison](https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS/DLEQ.hs#L77)
of the
[hash](https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS/ECC.hs#L146)
of DLEQ points.

Now, if we have `t+1` decrypted shares we can [recover a
secret](https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS.hs#L285).

Recovered secret can be
[verified](https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS.hs#L267)
as well, so we can be sure that secret recovered is the same escrow. To do it,
we need not just a proof and a secret, but
[commitments](https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS.hs#L268)
as well (actually, the [first
one](https://github.com/input-output-hk/pvss-haskell/blob/3c3926142c017255aa683256a1c8dd0c36cb9365/src/Crypto/PVSS.hs#L278).

## VSS Certificate

As [said
earlier](/cardano/differences/#coin-tossing-and-verifiable-secret-sharing), one
of the challenges while using a PVSS scheme is associating the public key used
for signing with the [public
key](https://github.com/input-output-hk/cardano-sl/blob/fefc39f058f5a053fc1e59bc3594bdadf7699ca0/core/Pos/Crypto/SecretSharing.hs#L57)
used for VSS scheme. This is solved by introducing [VSS
certificate](https://github.com/input-output-hk/cardano-sl/blob/f0de5f1dd31cc4afb0c67a24deca713cf6304814/core/Pos/Core/Vss/Types.hs#L46).

VSS certificate includes:

1.  Public key used for the VSS scheme (e.g. [VSS
    key](https://github.com/input-output-hk/cardano-sl/blob/fefc39f058f5a053fc1e59bc3594bdadf7699ca0/core/Pos/Crypto/SecretSharing.hs#L57)).
2.  Public key used for signing (e.g. [signing
    key](https://github.com/input-output-hk/cardano-sl/blob/f0de5f1dd31cc4afb0c67a24deca713cf6304814/core/Pos/Core/Vss/Types.hs#L51)).
3.  Index of an expiry epoch (e.g. the last epoch when this certificate was
    valid).
4.  Signature of a pair `(A,B)`, where `A` is a VSS key and `B` is an epoch
    index.

Initially, all stakeholders with enough stake to participate in randomness
generation (we call them [richmen](/glossary/#richman)) [have their own
certificates](https://github.com/input-output-hk/cardano-sl/blob/35c6bff7409472352140f5207a7c79c59d8eaa8f/ssc/Pos/Ssc/GodTossing/Workers.hs#L163).
When a new stakeholder having enough stake appears, or when an existing
certificate expires, a new certificate should be generated and [submitted to the
network](https://github.com/input-output-hk/cardano-sl/blob/35c6bff7409472352140f5207a7c79c59d8eaa8f/ssc/Pos/Ssc/GodTossing/Workers.hs#L166).
Other nodes accept this certificate if it's valid and if the node has enough
stake. Certificates are stored in blocks.

Please note that VSS certificate must be stable before usage! If an epoch we
retrieve certificates for is the first one (i.e. has index `0`), stable
certificates are [genesis
ones](https://github.com/input-output-hk/cardano-sl/blob/35c6bff7409472352140f5207a7c79c59d8eaa8f/ssc/Pos/Ssc/GodTossing/Functions.hs#L139).
Otherwise stable certificate are [non-expired certificates for the last known
slot](https://github.com/input-output-hk/cardano-sl/blob/35c6bff7409472352140f5207a7c79c59d8eaa8f/ssc/Pos/Ssc/GodTossing/Functions.hs#L141).
